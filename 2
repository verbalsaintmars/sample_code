#include <iostream>
#include <string>
#include <typeinfo>

using namespace std;

//not necessary in C++11
struct empty
{
};

template<typename T1, typename T2>
struct type_pair
{
   using head_t = T1;
   using tail_t = T2;
};

template<typename... Ts>
struct type_array
{
};

template<typename T, T VALUE>
struct static_parameter
{
};

template<typename T, T VALUE>
struct static_value : static_parameter<T, VALUE>
{
   static const T value = VALUE;
};

//-------------

template<typename... Ts>
struct front;

template<>
struct front<>;

template<typename T1, typename... Ts>
struct front<T1, Ts...>
{
   using type = T1;
};


template<typename... Ts>
struct back;

template<>
struct back<>;

template<typename T>
struct back<T>
{
   using type = T;
};

template<typename T1, typename... Ts>
struct back<T1, Ts... > : back<Ts...>
{
};

//----------

template<unsigned int N, typename... Ts>
struct type_at
{
      using type = empty;
};

template<typename T, typename... Ts>
struct type_at<0, T, Ts...>
{
   using type = T;
};

template<unsigned int N, typename T, typename... Ts>
struct type_at<N, T, Ts...>
{
   using type = typename type_at<N-1, Ts...>::type;
};

// <int, double>
// at 3

//----------

template<typename... Ts>
struct depth;

template<>
struct depth<> : static_value<unsigned int, 0>
{
};

template<typename T, typename... Ts>
struct depth<T, Ts...> : static_value<unsigned int, depth<Ts...>::value+1>
{

};

//<int,double>

//----------

template<typename T, typename... Ts>
struct type_index : static_value<int, -1>
{
};


template<typename T, typename... Ts>
struct type_index<T, T, Ts...> : static_value<int, 0>
{
};

template<typename T, typename T1, typename... Ts>
struct type_index<T, T1, Ts...> : static_value<int, (type_index<T, Ts...>::value == -1) ? -1 :
type_index<T, Ts...>::value + 1 >
{
};


//<int, double>

//----------
template<typename... Ts>
struct Pop;

template<typename T, typename... Ts>
struct Pop<T, Ts...>
{
   using type = Ts...;
};

template<typename... Ts>
struct Agglomerate;


template<>
struct Agglomerate<>
{
   Agglomerate(){cout << "test<>" << endl;}
};


template<typename T, typename... Ts>
struct Agglomerate<T, Ts...> : Agglomerate<Ts...>
{
   using value_type = T;
   value_type member;

   Agglomerate(){
      cout << "in test fin" << endl;
   }

};

//---------


template<typename T, typename... Ts>
T& ref(Agglomerate<T, Ts...>& a_)
{
   return a_.member;
}


//---------

template<typename agg_t, unsigned int N>
struct ref_trait
{
};



//---------

int main(){

   cout << typeid(back<int, double, std::string>::type).name() << endl;
   cout << typeid(front<int, double, std::string>::type).name() << endl;

   cout << typeid(type_at<2, double, double, std::string>::type).name() << endl;
   cout << typeid(type_at<12, int, double, std::string>::type).name() << endl;

   cout << depth<int, int, int>::value << endl;
   cout << depth<>::value << endl;

   cout << type_index<float, int, double, std::string>::value << endl;

   Agglomerate<double, double> derived;
   Agglomerate<double>& base = derived;

   Agglomerate<int, double> agg;
   ref<double>(agg) = 20.3;
   cout << ref<double>(agg) << endl;


}
